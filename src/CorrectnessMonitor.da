from controller import Controller
from algorand import User, create_gossip_neighbours, initial_context
from parameters import Parameters
import csv
import numpy as np
import time

class CorrectnessMonitor(process):

    def setup():
        self.storage = [True, True, True]
        self.final = True
        self.n_users = None
        self.n_traitors = None
        self.stake_traitors = None
        self.tau_step = None
        self.lambda_block = None
        self.lambda_step = None
        self.file = open('correctness.csv', 'w')
        self.csvwriter = csv.writer(self.file, lineterminator='\n')
        self.csvwriter.writerow(['users','traitors', 'stake traitors', 'tau_step (No. of Committee members)',
                                'lambda_block (Timeout for receiving a block)', 'lambda_step (Timeout for BAâ‹† step)',
                                'Consensus', 'Agreement', 'Validity', 'Liveness'])

    def receive(msg=('init', n_users, n_traitors, stake_traitors, tau_step, lambda_block, lambda_step)):
        self.n_users = n_users
        self.n_traitors = n_traitors
        self.stake_traitors = stake_traitors
        self.tau_step = tau_step
        self.lambda_block = lambda_block
        self.lambda_step = lambda_step
        self.storage = [True, True, True]
        self.final = True

    def receive(msg=('correctness', agr, val, liv, final)):
        oldagr, oldval, oldliv = self.storage
        self.final = self.final and final
        self.storage = [agr and oldagr, val and oldval, liv and oldliv]

    def receive(msg=('flush',)):
        consensus = 'Final' if self.final else 'Tentative'
        print([self.n_users, self.n_traitors, self.stake_traitors, self.tau_step, self.lambda_block,
                                 self.lambda_step, consensus] + self.storage)
        self.csvwriter.writerow([self.n_users, self.n_traitors, self.stake_traitors, self.tau_step, self.lambda_block,
                                 self.lambda_step, consensus] + self.storage)
        self.file.flush()

    def run():
        await(received(('done',), from_=parent()))


def main():
    params = Parameters()
    standard_values = [30, 5, 0.33, 10, 3, 3]
    values = [np.linspace(20, 50, 6), np.linspace(0, 15, 5), np.linspace(0, 0.36, 6), np.linspace(5, 15, 5),
              np.linspace(0.1, 4, 6), np.linspace(0.5, 4, 6)]
    context = initial_context()
    monitor = new(CorrectnessMonitor,())
    start(monitor)
    for i in range(0,len(standard_values)):
        n_users, n_traitors, stake_traitors, params.tau_step, params.lambda_block, params.lambda_step = standard_values
        for val in values[i]:
            n_users = standard_values[0] if i != 0 else int(val)
            n_traitors = standard_values[1] if i != 1 else int(val)
            stake_traitors = standard_values[2] if i != 2 else val
            params.tau_step = standard_values[3] if i != 3 else int(val)
            params.lambda_block = standard_values[4] if i != 4 else val
            params.lambda_step = standard_values[5] if i != 5 else val
            print(n_users, n_traitors, stake_traitors, params.tau_step, params.lambda_block, params.lambda_step)
            send(('init', n_users, n_traitors, stake_traitors, params.tau_step, params.lambda_block,
                  params.lambda_step), to=monitor)
            for k in range(3):
                ps = new(User, num=n_users)
                ctrl = new(Controller, (ps, params, context,
                                        n_traitors, stake_traitors,
                                        False, True, monitor))
                users_list = list(ps)
                for p in ps:
                    neighbours_set = create_gossip_neighbours(users_list, p)
                    setup(p, (neighbours_set, params, ctrl, context, True))
                start(ps)
                start(ctrl)
                await(received(('done',), from_=ctrl))
            send(('flush',), to=monitor)
            time.sleep(5)

    send(('done',), to=monitor)
