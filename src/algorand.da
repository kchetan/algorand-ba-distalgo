from controller import Controller
from context import Context
from block import Block
from H import H

class User(process):
    def setup(neighbours, ctrl, context):
        self.neighbours = neighbours
        self.controller = ctrl
        self.context = context
        self.curr_round_num = None
        self.curr_step = None

    def receive(msg=('Propose',)):
        pass

    def run():
        await(received(('done',), from_=parent()))

    def Gossip(round_num, step, initiator_id, h_last_block, value):
        send((round_num, step, initiator_id, h_last_block, value), to= self.neighbours)

    def receive(msg= (round_num, step, initiator_id, h_last_block, value), from_= p):
        if not sent((round_num, step, initiator_id, h_last_block, value), to= self.neighbours):
            send((round_num, step, initiator_id, h_last_block, value), to=self.neighbours)

    def UserSortition(round_num, step, role=None):
        assert role is None or role.lower() in 'committee' or role.lower() in 'proposer', \
            'Invalid role given for Sortition'
        assert round_num >= self.curr_round_num,\
            'Round No. {} for which Sortition is requested is over. Curr Round No. is {}'.format(round_num,
                                                                                                 self.curr_round_num)
        assert type(step) is str or step >= self.curr_step, \
            'Step No. {} for which Sortition is requested is over. Curr Step No. is {}'.format(step, self.curr_step)

        if role is None and (self.curr_round_num is None or self.curr_step is None
                             or self.curr_round_num < round_num or self.curr_step < step):
            send(('All', round_num, step), to=self.controller)
            await(received(('SortitionAll', proposers, committee, _step), from_=self.controller))
            self.committee = committee
            self.proposers = proposers
            self.curr_round_num = round_num
            self.curr_step = step

        elif role.lower() in 'committee' and (type(step) is str or self.curr_step < step):
            send(('Committee', step), to=self.controller)
            await(received(('SortitionCommittee', committee, _step), from_=self.controller))
            self.committee = committee
            self.curr_step = step

        elif role.lower() in 'proposer' and self.curr_round_num < round_num:
            send(('Proposer', round_num), to=self.controller)
            await(received(('SortitionProposers', proposers, _round_num), from_=self.controller))
            self.proposers = proposers
            self.curr_round_num = round_num

        if role.lower() in 'committee':
            return self.committee[self] if self in self.committee else 0
        elif role.lower() in 'proposer':
            return self in self.proposers
        else:
            return (self in self.proposers, self.committee[self] if self in self.committee else 0)

    def UserVerifySort(proc_id, role):
        if role.lower() == 'committee':
            if proc_id in self.committee:
                return self.committee[proc_id]
            return 0
        elif role.lower() == 'proposer':
            return int(self in self.proposers)

    # TODO : Stub for ProcessMsg
    def process_message(ctx, msg):
        ps_id, signed_m = msg  #TODO : The assignment will change depending on what the gossip message returns
        (round, step, initiator_id, hprev, value) = signed_m

        if hprev !=  H(ctx.prev_block()):
            return (0, None)

        votes = UserVerifySort(initiator_id, 'committee')

        return (votes, value)

def initial_context():
    ctx = Context()
    starting_block = Block('start')
    ctx.add_block(starting_block)
    return ctx

def main():
    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    lambda_t = int(sys.argv[2]) if len(sys.argv) > 2 else 2

    context = initial_context()
    ps = new(User, num=nprocs)

    ctrl = Controller(nprocs, ps, lambda_t, context)

    for p in ps: setup(p, (ps-{p}, ctrl, context))
    start(ps)
    start(ctrl)
    await(received(('done', ctrl)))