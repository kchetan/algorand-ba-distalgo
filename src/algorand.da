from controller import Controller
from context import Context
from block import Block
from H import H
import sys
import time
from parameters import *

class User(process):
    def setup(neighbours, ctrl, context):
        self.neighbours = neighbours
        self.controller = ctrl
        self.context = context
        self.curr_round_num = 0
        self.curr_step = None
        self.committee = None
        self.proposers = None
        self.blockofhash = {}
        self.highest_priority_block = None

    def receive(msg=('Propose',)):
        block = Block(str(self), self.curr_round_num, H(self.context.prev_block()))
        Gossip(('Proposal', self.curr_round_num, self, block))
        if self.highest_priority_block == None or self.highest_priority_block < (self, block):
            self.highest_priority_block = (self, block)

    def Gossip(msg):
        """

        Sends a message to all its neighbours.

        @param round_num: The current round of the BA.
        @type round_num: C{int}
        @param step: The current step of BA that is in progress.
        @type step: C{int}
        @param h_last_block: The hash of the previously selected block in the ledger.
        @type h_last_block: L{H(Block)}
        @param value: The hash value of the current proposed block
        @type value: L{H(Block)}
        @return:
        @rtype:
        """
        send(msg, to= self.neighbours)

    def receive(msg= ('CommiteeGossip', round_num, step, ps_id, h_last_block, value), from_= p):
        if not sent((round_num, step, ps_id, h_last_block, value), to= self.neighbours):
            send((round_num, step, ps_id, h_last_block, value), to=self.neighbours)

    def receive(msg=('Proposal', round_num, ps_id ,block), from_=p):
        if not sent((round_num, ps_id ,block), to=self.neighbours):
            block_hash = H(block)
            if block_hash not in self.blockofhash:
                self.blockofhash[block_hash] = (ps_id, block)
            if self.highest_priority_block == None or self.highest_priority_block < (ps_id, block):
                self.highest_priority_block = (ps_id, block)
            send((round_num, ps_id ,block), to=self.neighbours)

    def UserSortition(round_num, step, role=None):
        """

        Sends request to L{controller} to perform the soritition.


        @param round_num: The current round of the BA.
        @type round_num: C{int}
        @param step: The current step of BA that is in progress.
        @type step: C{int}
        @param role: A string mentioning the role the user.
        @type role: C(str)
        @return: Number of votes that can be cast if that user is a committee member else 0.
        @rtype: C(set)
        """
        output('User Sortition')
        assert role is None or role.lower() in 'committee' or role.lower() in 'proposer', \
            'Invalid role given for Sortition'
        assert round_num >= self.curr_round_num,\
            'Round No. {} for which Sortition is requested is over. Curr Round No. is {}'.format(round_num,
                                                                                                 self.curr_round_num)
        assert type(step) is str or step >= self.curr_step, \
            'Step No. {} for which Sortition is requested is over. Curr Step No. is {}'.format(step, self.curr_step)

        if role is None and (self.curr_round_num is None or self.curr_step is None
                             or self.curr_round_num < round_num or self.curr_step < step):
            send(('All', round_num, step), to=self.controller)
            await(some(received(('SortitionAll', proposers, committee, _step), from_=self.controller)))
            self.committee = committee
            self.proposers = proposers
            self.curr_round_num = round_num
            self.curr_step = step

        elif role.lower() in 'committee' and (type(step) is str or self.curr_step < step):
            output('Requesting Committee')
            send(('Committee', step), to=self.controller)
            await(some(received(('SortitionCommittee', committee, _step), from_=self.controller)))
            output('Received Committee')
            self.committee = committee
            self.curr_step = step

        elif role.lower() in 'proposer' and self.curr_round_num < round_num:
            send(('Proposer', round_num), to=self.controller)
            await(some(received(('SortitionProposers', proposers, _round_num), from_=self.controller)))
            self.proposers = proposers
            self.curr_round_num = round_num

        if role.lower() in 'committee':
            return self.committee[self] if self in self.committee else 0
        elif role.lower() in 'proposer':
            return self in self.proposers
        else:
            return (self in self.proposers, self.committee[self] if self in self.committee else 0)

    def UserVerifySort(proc_id, role):
        if role.lower() == 'committee':
            if proc_id in self.committee:
                return self.committee[proc_id]
            return 0
        elif role.lower() == 'proposer':
            return int(self in self.proposers)

    # TODO : Stub for ProcessMsg
    def ProcessMsg(ctx, msg):
        (round, step, initiator_id, hprev, value) = msg

        if hprev !=  H(ctx.prev_block()):
            return (0, None)

        votes = UserVerifySort(initiator_id, 'committee')

        return (votes, initiator_id, value)

    def CommiteeVote(context, round, step, value):
        """

        The procedure checks if the user is selected for the committee in a given round and step of BA. The
        CommitteeVote procedure to check if the user is chosen to participate in the committee. If the user
        is chosen for this step, the user gossips the message containing the value passed to CommitteeVote,
        which is typically the hash of some block.

        @param round: The current round of the BA.
        @type round: C{int}
        @param step: The current step of BA that is in progress.
        @type step: C{int}
        @param value: The highest priority block's hash that has been received by the user.
        @type value: L{H(Block)}
        @return:
        @rtype:
        """
        votes = UserSortition(round, step, role="committee")
        if votes > 0:
            Gossip(('CommiteeGossip', round, step, self, H(context.prev_block()), value))

    def CountVotes(context, round, step, T_value, tau_value, lambda_value):
        """

        This  procedure reads messages that belong to the current round and step. It processes the votes by calling
        the ProcessMsg() procedure for every message , which ensures that the vote is valid. Count the number of votes
        for each proposed blocks hash value and returns the block if the value is more than a threshold.

        @param context: It captures the current state of the ledger
        @type context: L{Context}
        @param round: The current round of the BA.
        @type round: C{int}
        @param step: The current step of BA that is in progress.
        @type step: C{int}
        @param T_value: Threshold of tau value for BA*
        @type T_value: C{float}
        @param tau_value: Expected number of block or values.
        @type tau_value: C{int}
        @param lambda_value: Timeout for receiving a block
        @type lambda_value: C{int}
        @return: Returns the hash of the block that has maximum votes.
        @rtype: L{H(Block)}
        """
        start = time.time()
        counts = dict()
        voters = set()
        #TODO: Implement vote counting
        msgs = setof((round_num, step, h_last_block, value), ((round_num, step, h_last_block, value), _) in received)
        while True:
            for m in msgs:
                votes, cmember_id, value = ProcessMsg(context, m)
                if cmember_id in voters or votes == 0:
                    continue
                voters.add(cmember_id)
                if value in counts:
                    counts[value] += votes
                else:
                    counts[value] = votes

                if counts[value] > T_value * tau_value:
                    return value
            if time.time() > start + lambda_value:
                return "TIMEOUT"


    def BinaryBA(context, round, block_hash):
        """
        In the procedure, it reaches consensus on one of two values: either the hash passed to BinaryBA() or the hash
        of the empty block. BinaryBA() relies on Reduction() to ensure that at most one non-empty block hash is passed
        to BinaryBA() by all honest users.


        @param context: It captures the current state of the ledger
        @type context: L{Context}
        @param round: The current round of the BA.
        @type round: C{int}
        @param block_hash: The highest priority block's hash that has been received by the user.
        @type block_hash: L{H(Block)}
        @return: Returns the hash of the block that has been chosen.
        @rtype: L{H(Block)}
        """
        # TODO: need to Implement Binary BA block.
        output('Binary BA*')
        return H()

    def Reduction(context, round, hblock):
        """
        Converts the problem of reaching consensus on an arbitarary value to reaching on consensus on one of the two
        values either a specific proposed block or hash of an empty hash block.

        @param context: It captures the current state of the ledger
        @type context: L{Context}
        @param round: The current round of the BA.
        @type round: C{int}
        @param hblock: The highest priority block's hash that has been received by the user.
        @type hblock: L{H(Block)}
        @return: Returns the hash of the block that has been chosen.
        @rtype: L{H(Block)}
        """
        output('Reduction')
        CommiteeVote(context, round, "REDUCTION_ONE", hblock)
        if await(False):
            pass
        elif timeout(lambda_block + lambda_step):
            pass
        output('After CommitteeVote REDUCTION_ONE')
        hblock1 = CountVotes(context, round, "REDUCTION_ONE", T_step, tau_step,
                             lambda_block + lambda_step)
        output('After CountVotes for REDUCTION_ONE')
        empty_hash = H()  #TODO: need to create empty block.
        if hblock1 == "TIMEOUT":
            CommiteeVote(context, round, "REDUCTION_TWO", empty_hash)
        else:
            CommiteeVote(context, round, "REDUCTION_TWO", hblock1)
        output('After CommitteeVote REDUCTION_TWO')
        hblock2 = CountVotes(context, round, "REDUCTION_TWO", T_step, tau_step, lambda_step)
        output('After CountVotes for REDUCTION_TWO')
        if hblock2 == "TIMEOUT":
            return empty_hash
        return hblock2

    def BA(context, round, block):
        """
        The highest level Byzantine Agreement Protocol procedure that is run in each user process, to come to consensus
        on proposed or an empty block.
        @param context: It captures the current state of the ledger
        @type context: L{Context}
        @param round: The current round of the BA.
        @type round: C{int}
        @param block: The highest priority block that has been received by the user.
        @type block: L{Block}
        @return: tuple containing status of consensus and the block which has been agreed upon.
        @rtype: C{str}, L{Block}
        """
        output('Starting BA*')
        hblock = Reduction(context, round, H(block))
        output('Reduction Done')
        hblock_star = BinaryBA(context, round, hblock)
        output('BinaryBA* Done')
        r = CountVotes(context, round, "FINAL", T_final, tau_final, lambda_step)
        output('After CountVotes for FINAL')
        if hblock_star == r:
            return "FINAL", block  #TODO: Need to Get the BLOCKOFHASH(hblock_star)
        else:
            return "TENTATIVE", block  #TODO: Need to Get the BLOCKOFHASH(hblock_star)

    def anyof(s):
        """return any element of set s if s is not empty or 'None' otherwise"""
        return next(iter(s)) if s else None

    def run():
        await(received(('start_BA',), from_=self.controller))
        print(self.highest_priority_block, self, '*'*20)
        result = BA(self.context, 0, self.highest_priority_block[1])
        output('Completed BA*')

        send(('result', result), to=self.controller)
        await(received(('Received result',), from_=self.controller))

        send(('done',), to=self.controller)
        output('terminating User ', self)
        # await(received(('done',), from_=parent()))

def initial_context():
    """
    The initial context of the ledger.

    @return: The context object with a starting block.
    @rtype: L{Block}
    """
    ctx = Context()
    starting_block = Block('start')
    ctx.add_block(starting_block)
    return ctx

def main():
    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    lambda_t = int(sys.argv[2]) if len(sys.argv) > 2 else 2

    context = initial_context()
    ps = new(User, num=nprocs)
    ctrl = new(Controller, (ps, lambda_t, context, 0.2))

    for p in ps: setup(p, (ps-{p}, ctrl, context))
    start(ps)
    start(ctrl)
    await(received(('done',), from_=ctrl))
