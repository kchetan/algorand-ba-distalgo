import random
import numpy as np
from block import Block
import parameters as params
from H import H

class Controller(process):

    def setup(processes, lambda_t, context, n_traitors, stake_traitors, byzantine_proposer, byzantine_committee):
        self.nprocs = len(processes)
        self.ps = processes
        self.ps_list = list(processes)
        self.lambda_t = lambda_t
        self.context = context
        self.n_traitors = n_traitors
        self.stake_traitors = stake_traitors
        self.step = None
        self.curr_round = None
        self.W = dict()
        self.committee = None
        self.proposers = None
        self.num_committee = params.tau_step
        self.num_proposers = params.tau_proposer
        self.num_final_committee = params.tau_final
        self.results = dict()
        self.committees_created = dict()
        self.proposed_blocks = {}

        tr = np.random.choice(np.arange(0, self.nprocs), size=n_traitors, replace=False)
        self.traitors = {self.ps_list[i] for i in tr}
        self.honest_users = self.ps - self.traitors
        output('Honest: {}'.format(self.honest_users))
        output('Traitors: {}'.format(self.traitors))

        self.byzantine_proposer = byzantine_proposer
        self.byzantine_committee = byzantine_committee

    def receive(msg=('Proposal', round_num, ps_id, block)):
        if round_num in self.proposed_blocks:
            self.proposed_blocks[round_num].add(block)
        else:
            self.proposed_blocks[round_num] = {block}

    def receive(msg=('IsUserInCommittee', round_num, step, q), from_=p):
        if step == 'FINAL':
            self.committees_created[step] = Sortition(self.num_final_committee, round_num, step, 'Committee')
        elif step not in self.committees_created:
            self.committees_created[step] = Sortition(self.num_committee, round_num, step, 'Committee')

        if q in self.committees_created[step]:
            send(('InCommitteeReply', round_num, step, self.committees_created[step][q]), to=p)
        else:
            send(('InCommitteeReply', round_num, step, 0), to=p)

    def receive(msg=('IsUserProposer', round_num, q), from_=p):
        if curr_round is None or curr_round < round_num:
            Sortition(self.num_proposers, round_num, None, 'Proposers')
        send(('IsProposerReply', round_num, int(q in self.proposers)), to=p)

    def Sortition(num_role, round, step, role):
        """

        This function is a reinterpretation of the Algorand Sortition algorithm. Instead of relying upon a VRF 
        to allow users to know whether they are committee members, proposers, or just replicas, at each step/round, we
        generate a list of members for each role the first time this function is called at each step/round.
        Committee Members are chosen according to a set of weights generated randomly each step. The committee
        members can cast multiple votes, and hence, are chosen using a Normal random process. 
        Proposers are sampled randomly from the set of nodes in self.ps.

        @param num_role: Number of processes needed by calling function for given role
        @type num_role: int
        @param round: Round number for performing proposer selection. No effect on committee selection
        @type round: int
        @param step: Step number for performing committee selection.
            No effect on proposer selection
        @type step: int
        @param role: Role for which users are being chosen: Proposer or Committee.
            No other roles are accepted.
        @type role: str
        @return: List consisting of all node names
            assigned to "role"
        """
        assert role.lower() in 'committee' or role.lower() in 'proposers',\
            '[controller.da] Unrecognized role name given to Sortition'
        if role.lower() in 'committee':
            assert self.step is None or type(step) is str or type(self.step) is str or self.step == step or self.step == step - 1, \
                '[controller.da] Sortition generated committee for step {}, but curr step is {}'.format(self.step, step)
            if self.step is None or self.step != step or self.step < step:
                output('Committee Sortition Requirements Satisfied')
                selection = list(np.random.choice(np.arange(0, self.nprocs), size=num_role, replace=True, p=self.W[round]))
                self.committee = {self.ps_list[i]:selection.count(i) for i in set(selection)}
                self.step = step
                output('Finished Committee Sortition - STEP: {}'.format(step))
                output('Committee at STEP {} = {}'.format(step, self.committee))
            return self.committee

        elif role.lower() in 'proposers':
            assert self.curr_round is None or self.curr_round == round or self.curr_round == round - 1, \
                '[controller.da] Sortition generated proposers for round {}, but curr round is {}'.format(self.curr_round,
                                                                                                          round)
            if self.curr_round is None or self.curr_round < round:
                p = set(np.random.choice(np.arange(0, self.nprocs), size=num_role, replace=True, p=self.W[round]))
                self.proposers = {self.ps_list[i] for i in p}
                self.curr_round = round
            return self.proposers

    def VerifySort(proc_id):
        """

        This function is a reinterpretation of the Algorand VerifySort algorithm. Instead of relying upon a VRF
        to independently allow users to know how many votes a committee member is allowed to cast, we allow them to
        query the controller for this information.

        @param proc_id: The node ID which is being verified.
        @return: Number of votes assigned to proc_id.

        """
        if self.committee and proc_id in self.committee:
            return self.committee[proc_id]
        return 0

    def receive(msg= ('result', result), from_=p):
        self.results[p] = (str(result[0]) if type(result[0]) is Block else result[0], result[1])
        send(('Received result',), to=p)

    def isEmptyBlock(block:Block):
        return block.get_round() == self.curr_round and block.get_value() == None and block.get_timestamp() == None \
            and block.get_prev_hash() == H(self.context.prev_block())

    def distribute_stakes(num_indices: int, total_stake: float):
        stakes = list()
        for i in range(num_indices-1):
            stakes.append(np.random.uniform(0, total_stake))
            total_stake -= stakes[-1]
        stakes.append(total_stake)
        return stakes

    def initialize_stakes(round_num):
        if round_num not in self.W:
            honest_stakes = distribute_stakes(self.nprocs - self.n_traitors, 1 - self.stake_traitors)
            traitor_stakes = distribute_stakes(self.n_traitors, self.stake_traitors)

            self.W[round_num] = honest_stakes + traitor_stakes
            output('Stakes: {}'.format({self.ps_list[i]:self.W[round_num][i] for i in range(0, self.nprocs)}))
        return self.W[round_num]

    def run():

        initialize_stakes(0)
        send(('YouAreTraitor',), to=self.traitors)
        proposerSet = Sortition(self.num_proposers, 0, None, 'Proposer')
        if self.byzantine_proposer:
            max_prop_id = max(proposerSet)
            send(('Propose', self.curr_round), to=proposerSet-{max_prop_id})
            send(('ByzantinePropose', self.curr_round), to=max_prop_id)
        else:
            send(('Propose', self.curr_round), to=proposerSet)

        if await(False):
            pass
        elif timeout(lambda_t):
            pass

        send(('start_BA', ) , to=ps)

        await(each(p in ps, has=received(('done',), from_=p)))

        output('Results:')
        tentative_blocks = set(block for status, block in self.results.values() if status == 'TENTATIVE')
        final_blocks = set(block for status, block in self.results.values() if status == 'FINAL')
        tentative_users = dict()
        final_users = dict()
        for user, (status, block) in self.results.items():
            if status == 'TENTATIVE':
                if block in tentative_users:
                    tentative_users[block].append(user)
                else:
                    tentative_users[block] = [user]
            else:
                if block in final_users:
                    final_users[block].append(user)
                else:
                    final_users[block] = [user]

        if len(tentative_blocks) == 0 and len(final_blocks) == 1:
            output('Consensus Reached')
            for x in final_blocks:
                print('Final Block:\n{}'.format(x))
        else:
            output('Failed to reach consensus')
            print('Tentative Blocks:')
            for block in tentative_blocks:
                print('List of users with this block: {}'.format(tentative_users[block]))
                print(block)
            print('Final Blocks:')
            for block in final_blocks:
                print('List of users with this block: {}'.format(final_users[block]))
                print(block)

        # Correctness Testing
        print("\n Correctness Testing")
        total_blocks = set(tentative_blocks).union(set(final_blocks))
        if len(total_blocks) != 1:
            print('1) Safety Violated')
        else:
            print('1) Safety Sastisfied')
            for block in total_blocks:
                if block in self.proposed_blocks[block.get_round()] or self.isEmptyBlock(block):
                    print('2) Agreement Satisfied\n')
                else:
                    print('2) Agreement Violated\n')
        send(('done',), to=parent())

