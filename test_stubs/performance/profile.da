from block import Block
from H import H
import time
import argparse
import numpy as np
from tqdm import trange


class PerformanceTimer(object):

    def __init__(self):
        self.__start_time = 0
        self.__end_time = 0
        self.__logs = list()

    def start(self):
        self.__start_time = time.perf_counter()

    def end(self):
        self.__end_time = time.perf_counter()
        self.__logs.append(self.__end_time - self.__start_time)

    def get_logs(self):
        return self.__logs

    def get_total(self):
        return np.sum(self.__logs)

    def get_mean(self):
        return np.mean(self.__logs)

    def get_std(self):
        return np.std(self.__logs)

    def clear_logs(self):
        self.__logs = list()


class BlockSender(process):

    def setup(neighbor, block_size, max_rounds):
        self.num_rounds = 0
        self.iteration = 0

    def receive(msg=('Pong', block, _, _), from_=p):
        num_rounds += 1
        # output('Ping {}'.format(num_rounds))
        send(('Ping', block, num_rounds, iteration), to=neighbor)

    def receive(msg=('Start', block, r)):
        num_rounds = 0
        iteration = r
        # output('Ping {}'.format(0))
        send(('Ping', block, num_rounds, iteration), to=neighbor)

    def run():
        await(received(('done',), from_=parent()))


class BlockReceiver(process):

    def setup(neighbor, max_rounds): pass

    def receive(msg=('Ping', block, curr_round, iteration), from_=p):
        if curr_round < max_rounds:
            # output('Pong {}'.format(curr_round))
            send(('Pong', block, curr_round, iteration), to=p)
        else:
            send(('Completed', iteration), to=parent())

    def run():
        await(received(('done',), from_=parent()))


def profile_block_generation():
    output('############## Profile block generation ##############\n')
    empty_hash = H()
    s = 'ABCDEFG'

    start = time.perf_counter()
    block = Block(s, 1, empty_hash)
    end = time.perf_counter()
    output('Time taken to create normal block = {} s'.format(end - start))

    start = time.perf_counter()
    hash = H(block)
    end = time.perf_counter()
    output('Time taken to hash normal block = {} s'.format(end - start))
    output(hash[:20])

    print('')

    start = time.perf_counter()
    block_2 = Block(s + 'A' * 1024, 2, hash)
    end = time.perf_counter()
    output('Time taken to create 1 KB block = {} s'.format(end - start))

    start = time.perf_counter()
    hash_2 = H(block_2)
    end = time.perf_counter()
    output('Time taken to hash 1 KB block = {} s'.format(end - start))
    output(hash_2[:20])

    print('')

    start = time.perf_counter()
    block_3 = Block(s + 'A' * 1024 * 1024, 3, hash_2)
    end = time.perf_counter()
    output('Time taken to create 1 MB block = {} s'.format(end - start))

    start = time.perf_counter()
    hash_3 = H(block_3)
    end = time.perf_counter()
    output('Time taken to hash 1 MB block = {} s'.format(end - start))
    output(hash_3[:20])

    print('')
    output('############## End of Profile ##############')


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--profile-transmission', help='Run function: profile_block_transmission', dest='pt',
                        action='store_true', default=False)
    parser.add_argument('-b', '--block-size', help='Size of block for profiling transmission', type=int,
                        dest='block_size', default=0)
    parser.add_argument('-r', '--rounds', help='Number of rounds for profiling transmission', type=int,
                        dest='rounds', default=5)

    parser.add_argument('-g', '--profile-generation', help='Run function: profile_block_generation', dest='pg',
                        action='store_true', default=False)

    parser.add_argument('-n', '--repeats', help='Number of repeats experiment', type=int,
                        dest='repeats', default=10)

    args = vars(parser.parse_args())

    if not (args['pt'] or args['pg']):
        output('No test specified.\n')
        print(parser.print_help())
        return

    if args['pg']:
        profile_block_generation()

    if args['pt']:
        block_size, max_rounds, repeats = int(args['block_size']*1024), args['rounds'], args['repeats']

        rudata = PerformanceTimer()

        sender = new(BlockSender)
        receiver = new(BlockReceiver, (sender, max_rounds))
        setup(sender, (receiver, block_size, max_rounds))
        start({sender, receiver})
        time.sleep(0.5)

        block = Block(str(self)+'A'*block_size, 0, H())

        for i in trange(repeats):
            rudata.start()
            send(('Start', block, i), to=sender)
            await(received(('Completed', i), from_=receiver))
            rudata.end()

        send(('done',), to={sender, receiver})

        output('Total time taken = {} s'.format(rudata.get_total()))
        output('Avg time taken = {} s'.format(rudata.get_mean()))
        output('Std of time taken = {} s'.format(rudata.get_std()))